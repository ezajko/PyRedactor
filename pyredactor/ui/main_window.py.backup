#!/usr/bin/env python3
# Licensed under GPLV3.0
# (c) 2025 Ernedin Zajko <ezajko@root.ba>

"""
Main Window for PyRedactor Application
"""

import sys
import os
import json
import subprocess
from functools import partial
import pytesseract

from PySide6.QtWidgets import (
    QApplication, QMainWindow, QLabel, QToolBar, QGraphicsView, QGraphicsScene, QFileDialog,
    QRubberBand, QGraphicsRectItem, QMessageBox, QStatusBar, QDockWidget, QListWidget, QListWidgetItem,
    QComboBox, QCheckBox, QProgressDialog
)
from PySide6.QtGui import QAction, QIcon, QPixmap, QColor, QBrush, QPen
from PySide6.QtCore import Qt, QPoint, QRect, QSize, QRectF, QThread, Signal

from ..utils.icon_utils import get_icon_from_theme, create_colorful_icon
from PIL.ImageQt import ImageQt
import io
import copy

from .graphics_items import ResizableRectItem, PhotoViewer

from ..core.services.document_management import DocumentManagementService
from ..core.services.redaction import RedactionService
from ..core.services.settings import SettingsManagementService

from ..application.model_worker import ModelWorker
from ..application.export_worker import ExportWorker
from ..application.document_loader_worker import DocumentLoaderWorker
from ..application.batch_worker import BatchOperationWorker
from PySide6.QtCore import QThread

class MainWindow(QMainWindow):
    def __init__(self, document_service: DocumentManagementService, redaction_service: RedactionService, settings_service: SettingsManagementService):
        super().__init__()

    print("[DEBUG] MainWindow: __init__ started")

    self.document_service = document_service
    self.redaction_service = redaction_service
    self.settings_service = settings_service

    self.setWindowTitle("PyRedactor")
    self.resize(1300, 900)

    # --- ModelWorker for background model operations ---
    # Temporarily disable threading to fix issues
    # self.model_thread = QThread()
    self.model_worker = ModelWorker()
    self.model_worker.document_service = self.document_service
    # self.model_worker.moveToThread(self.model_thread)
    # self.model_thread.start()
    # self.model_worker.save_finished.connect(self.on_save_finished)
    # self.model_worker.export_finished.connect(self.on_export_finished)
    # self.model_worker.batch_update_finished.connect(self.on_batch_update_finished)

    self.fill_color = 'black'
    self.output_quality = 'ebook'
    self.history_length = 30
    self.color_list = ["#000000", "#ffffff", "#ff0000", "#00ff00"] # Black, White, Red, Green (hex codes)

    self.page_list = QListWidget()
    self.scene = QGraphicsScene()
    self.view = PhotoViewer(self)
    self.view.setScene(self.scene)

    self.ocr_enabled = True

    # Image enhancement options
    self.enhancement_enabled = False
    self.enhancement_brightness = 1.0
    self.enhancement_contrast = 1.0
    self.enhancement_sharpness = 1.0
    self.enhancement_auto_level = True
    self.enhancement_deskew = True
    self.enhancement_denoise = True

        # TEMPORARILY DISABLED OCR LANGUAGE DETECTION TO AVOID HANGS
        # available_langs = self.get_available_ocr_languages()
        available_langs = ["eng"]  # Default to English
        
        if available_langs:
            self.ocr_lang = available_langs[0]
        else:
            self.ocr_lang = "eng"
        
    self.statusBar().showMessage(
    f"Loaded: {os.path.basename(document.file_path)} | {document.file_path} | Pages: {len(document.pages)} | Markers: {document.total_rectangles}"
    )
    else:
    QMessageBox.critical(self, "Error", "Document loading was cancelled or failed.")

    def _on_load_error(self, error_message):
    """Handle document loading errors"""
    if hasattr(self, '_load_progress_dialog'):
    self._load_progress_dialog.close()
    delattr(self, '_load_progress_dialog')
    QMessageBox.critical(self, "Error", f"Failed to open file: {error_message}")

    def show_page(self, page_num: int):
    document = self.document_service.get_current_document()
    if document and 0 <= page_num < document.page_count:
    self.document_service.navigate_to_page(document, page_num)
    self.scene.clear()
    page = document.get_current_page()
    if page and page.image:
    self.scene.clear()
    qimage = ImageQt(page.image)
    pixmap = QPixmap.fromImage(qimage)
    self.scene.addPixmap(pixmap)
    self.view.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

    for rect_entity in page.rectangles:
    # Calculate width and height from start/end points
    x0, y0 = rect_entity.start_point
    x1, y1 = rect_entity.end_point
    width = x1 - x0
    height = y1 - y0
    rect_item = ResizableRectItem(QRectF(0, 0, width, height), entity_id=rect_entity.id)
    rect_item.setPos(x0, y0)
    rect_item.setBrush(QBrush(QColor(rect_entity.color))) # Use base color
    rect_item.setOpacity(0.5) # 50% transparency
    self.scene.addItem(rect_item)

    self.update_status_bar()
    self.page_list.setCurrentRow(page_num)

    def next_page(self):
    document = self.document_service.get_current_document()
    if document:
    if self.document_service.navigate_next_page(document):
    self.show_page(document.current_page_index)

    def prev_page(self):
    document = self.document_service.get_current_document()
    if document:
    if self.document_service.navigate_previous_page(document):
    self.show_page(document.current_page_index)

    def on_page_selected(self, item):
    row = self.page_list.row(item)
    self.show_page(row)

    def update_status_bar(self):
    document = self.document_service.get_current_document()
    if document:
    file_info = f"{os.path.basename(document.file_path)} | {document.file_path}" if document.file_path else "Untitled"
    page_info = f"Page {document.current_page_index + 1} of {document.page_count}"
    marker_info = f"Markers: {document.total_rectangles}"
    self.statusBar().showMessage(f"{file_info} | {page_info} | {marker_info}")
    else:
    self.statusBar().showMessage("No file loaded")

    def zoom_in(self):
    self.view.scale(1.2, 1.2)

    def zoom_out(self):
    self.view.scale(0.8, 0.8)



    def delete_all(self):
    """
    Remove all markers from the current page and update the model.
    """
    document = self.document_service.get_current_document()
    if document:
    page = document.get_current_page()
    if page:
    self.redaction_service.clear_all_redactions(page)
    self.show_page(document.current_page_index)



    def save_edited_document(self):
    document = self.document_service.get_current_document()
    if not document:
    QMessageBox.warning(self, "Save Document", "No document to save.")
    return

    if not document.file_path:
    self.save_as_edited_document()
    return

    base_name = os.path.splitext(os.path.basename(document.file_path))[0]
    dir_name = os.path.dirname(document.file_path)
    redacted_filename = f"{base_name}.Redacted.pdf"
    save_file_path = os.path.join(dir_name, redacted_filename)

    # Use threaded export with progress dialog
    self._export_document_threaded(save_file_path)

    def _export_document_threaded(self, save_file_path):
    """Export document using background thread with enhanced progress dialog"""
    document = self.document_service.get_current_document()
    if not document:
    return

    # Create enhanced progress dialog
    self._export_progress_dialog = QProgressDialog("Exporting document...", "Cancel", 0, 100, self)
    self._export_progress_dialog.setWindowModality(Qt.WindowModal)
    self._export_progress_dialog.setWindowTitle("Export Progress")
    self._export_progress_dialog.setMinimumDuration(0)  # Show immediately
    self._export_progress_dialog.setAutoClose(False)
    self._export_progress_dialog.setAutoReset(False)
    self._export_progress_dialog.setFixedSize(400, 120)  # Fixed size for better appearance

    # Create worker and thread
    settings = {
    "ocr_enabled": self.ocr_enabled,
    "ocr_lang": self.ocr_lang,
    "output_quality": self.output_quality
    }

    self.export_thread = QThread()
    self.export_worker = ExportWorker(
    self.document_service,
    document,
    save_file_path,
    settings
    )

    # Move worker to thread
    self.export_worker.moveToThread(self.export_thread)

    # Connect signals
    self.export_thread.started.connect(self.export_worker.export_document)
    self.export_worker.progress_update.connect(self._update_export_progress)
    self.export_worker.finished.connect(self._on_export_finished)
    self.export_worker.error.connect(self._on_export_error)
    self.export_worker.finished.connect(self.export_thread.quit)
    self.export_worker.finished.connect(self.export_worker.deleteLater)
    self.export_thread.finished.connect(self.export_thread.deleteLater)
    self._export_progress_dialog.canceled.connect(self.export_worker.cancel)

    # Start the export
    self.export_thread.start()
    self._export_progress_dialog.show()

    def _update_export_progress(self, message, percentage):
    """Update export progress dialog and status bar"""
    if hasattr(self, '_export_progress_dialog'):
    self._export_progress_dialog.setLabelText(message)
    self._export_progress_dialog.setValue(percentage)
    # Update status bar with current operation
    self.statusBar().showMessage(f"Exporting: {message}")

    def _on_export_finished(self, success, message, file_path):
    """Handle export completion"""
    # Close progress dialog
    if hasattr(self, '_export_progress_dialog'):
    self._export_progress_dialog.close()
    delattr(self, '_export_progress_dialog')

    # Show result message
    if success:
    QMessageBox.information(self, "Export Successful", message)
    else:
    QMessageBox.critical(self, "Export Failed", message)

    def _on_export_error(self, error_message):
    """Handle export errors"""
    if hasattr(self, '_export_progress_dialog'):
    self._export_progress_dialog.close()
    delattr(self, '_export_progress_dialog')
    QMessageBox.critical(self, "Export Error", f"An error occurred during export:\n{error_message}")

    def save_as_edited_document(self):
    document = self.document_service.get_current_document()
    if not document:
    QMessageBox.warning(self, "Save Document As", "No document to save.")
    return

    suggested_filename = "redacted_document.pdf"
    if document.file_path:
    base_name = os.path.splitext(os.path.basename(document.file_path))[0]
    suggested_filename = f"{base_name}.Redacted.pdf"

    save_file_path, _ = QFileDialog.getSaveFileName(
    self, "Save Document As", suggested_filename, "PDF Files (*.pdf)"
    )
    if save_file_path:
    self._export_document_threaded(save_file_path)

    def about(self):
    QMessageBox.about(self, "About PyRedactor",
    "PyRedactor PDF Redaction Software\n\n"
    "Version 0.1.0\n"
    "Licensed under GPL V3.0\n\n"
    "Â©2025 Ernedin Zajko <ezajko@root.ba>")

    def trigger_batch_marker_operation(self, update_func, operation_name="Batch Operation"):
    """
    Trigger a batch marker/model operation in the background using BatchOperationWorker.
    update_func should be a callable that takes the document and performs updates.
    """
    document = self.document_service.get_current_document()
    if not document:
    QMessageBox.warning(self, "Batch Operation", "No document loaded.")
    return

    # Create enhanced progress dialog
    self._batch_progress_dialog = QProgressDialog(f"{operation_name} in progress...", "Cancel", 0, 100, self)
    self._batch_progress_dialog.setWindowModality(Qt.WindowModal)
    self._batch_progress_dialog.setWindowTitle(operation_name)
    self._batch_progress_dialog.setMinimumDuration(0)
    self._batch_progress_dialog.setAutoClose(False)
    self._batch_progress_dialog.setAutoReset(False)
    self._batch_progress_dialog.setFixedSize(400, 120)  # Fixed size for better appearance

    # Create worker and thread
    self.batch_thread = QThread()
    self.batch_worker = BatchOperationWorker(document, update_func, operation_name)

    # Move worker to thread
    self.batch_worker.moveToThread(self.batch_thread)

    # Connect signals
    self.batch_thread.started.connect(self.batch_worker.execute_batch_operation)
    self.batch_worker.progress_update.connect(self._update_batch_progress)
    self.batch_worker.finished.connect(self._on_batch_finished)
    self.batch_worker.error.connect(self._on_batch_error)
    self.batch_worker.finished.connect(self.batch_thread.quit)
    self.batch_worker.finished.connect(self.batch_worker.deleteLater)
    self.batch_thread.finished.connect(self.batch_thread.deleteLater)
    self._batch_progress_dialog.canceled.connect(self.batch_worker.cancel)

    # Start the batch operation
    self.batch_thread.start()
    self._batch_progress_dialog.show()

    def _update_batch_progress(self, message, percentage):
    """Update batch operation progress dialog and status bar"""
    if hasattr(self, '_batch_progress_dialog'):
    self._batch_progress_dialog.setLabelText(message)
    self._batch_progress_dialog.setValue(percentage)
    # Update status bar with current operation
    self.statusBar().showMessage(f"Batch Operation: {message}")

    def _on_batch_finished(self, success, message):
    """Handle batch operation completion"""
    # Close progress dialog
    if hasattr(self, '_batch_progress_dialog'):
    self._batch_progress_dialog.close()
    delattr(self, '_batch_progress_dialog')

    # Show result message
    if success:
    QMessageBox.information(self, "Batch Operation", message)
    # Optionally refresh the UI
    document = self.document_service.get_current_document()
    if document:
    self.show_page(document.current_page_index)
    else:
    QMessageBox.critical(self, "Batch Operation", message)

    def _on_batch_error(self, error_message):
    """Handle batch operation errors"""
    if hasattr(self, '_batch_progress_dialog'):
    self._batch_progress_dialog.close()
    delattr(self, '_batch_progress_dialog')
    QMessageBox.critical(self, "Batch Operation Error", f"An error occurred during batch operation:\n{error_message}")

    def on_batch_update_finished(self, success, message):
    if success:
    QMessageBox.information(self, "Batch Operation", message)
    # Optionally refresh the UI
    self.show_page(self.document_service.get_current_document().current_page_index)
    else:
    QMessageBox.critical(self, "Batch Operation", message)

    def on_save_finished(self, success, message):
    if success:
    QMessageBox.information(self, "Save Document", message)
    else:
    QMessageBox.critical(self, "Save Document", message)

    def on_export_finished(self, success, message):
    if success:
    QMessageBox.information(self, "Export PDF", message)
    else:
    QMessageBox.critical(self, "Export PDF", message)

    QMessageBox.critical(self, "Export PDF", message)

    event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    sys.exit(app.exec())
    def toggle_enhancement_options(self):
    """Toggle image enhancement options dialog"""
    from .dialogs.enhancement_options_dialog import EnhancementOptionsDialog

    dialog = EnhancementOptionsDialog(
    self,
    enhancement_enabled=self.enhancement_enabled,
    brightness=self.enhancement_brightness,
    contrast=self.enhancement_contrast,
    sharpness=self.enhancement_sharpness,
    auto_level=self.enhancement_auto_level,
    deskew=self.enhancement_deskew,
    denoise=self.enhancement_denoise
    )

    if dialog.exec() == QDialog.Accepted:
    values = dialog.get_values()
    self.enhancement_enabled = values["enhancement_enabled"]
    self.enhancement_brightness = values["brightness"]
    self.enhancement_contrast = values["contrast"]
    self.enhancement_sharpness = values["sharpness"]
    self.enhancement_auto_level = values["auto_level"]
    self.enhancement_deskew = values["deskew"]
    self.enhancement_denoise = values["denoise"]

    # Pass settings to document repository
    if hasattr(self.document_service, "document_repository"):
    self.document_service.document_repository.set_enhancement_settings(
    enabled=self.enhancement_enabled,
    brightness=self.enhancement_brightness,
    contrast=self.enhancement_contrast,
    sharpness=self.enhancement_sharpness,
    auto_level=self.enhancement_auto_level,
    deskew=self.enhancement_deskew,
    denoise=self.enhancement_denoise
    )

    # Show status message
    if self.enhancement_enabled:
    self.statusBar().showMessage("Image enhancement enabled - will be applied to new documents")
    else:
    self.statusBar().showMessage("Image enhancement disabled")
